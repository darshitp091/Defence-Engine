import os
import time
import hashlib
import threading
import subprocess
from collections import deque
from typing import Dict, List, Optional, Tuple
import json
import psutil
import mimetypes
from pathlib import Path

class RealTimeMalwareScanner:
    def __init__(self):
        self.scanning_active = False
        self.scanning_thread = None
        self.malware_signatures = set()
        self.suspicious_patterns = [
            b'MZ',  # PE executable header
            b'ELF',  # Linux executable
            b'\x7fELF',  # ELF magic number
            b'PK\x03\x04',  # ZIP file (potential malware container)
            b'Rar!',  # RAR file
            b'\x1f\x8b',  # GZIP
            b'%PDF',  # PDF (potential exploit)
            b'<script',  # JavaScript
            b'javascript:',  # JavaScript protocol
            b'eval(',  # JavaScript eval
            b'base64_decode',  # PHP base64 decode
            b'shell_exec',  # PHP shell execution
            b'system(',  # System call
            b'cmd.exe',  # Windows command
            b'/bin/sh',  # Unix shell
            b'powershell',  # PowerShell
            b'wscript',  # Windows Script Host
            b'cscript',  # Windows Script Host
            b'regsvr32',  # Windows DLL registration
            b'rundll32',  # Windows DLL execution
        ]
        self.scan_results = deque(maxlen=10000)
        self.quarantine_dir = "quarantine"
        self.scan_stats = {
            'files_scanned': 0,
            'malware_detected': 0,
            'files_quarantined': 0,
            'false_positives': 0,
            'scan_errors': 0
        }
        self.scan_directories = [
            os.path.expanduser("~\\Downloads"),
            os.path.expanduser("~\\Desktop"),
            os.path.expanduser("~\\Documents"),
            "C:\\Windows\\Temp",
            "C:\\Temp"
        ]
        self.scan_extensions = {
            '.exe', '.dll', '.sys', '.bat', '.cmd', '.ps1', '.vbs', '.js',
            '.jar', '.zip', '.rar', '.7z', '.tar', '.gz', '.pdf', '.doc',
            '.docx', '.xls', '.xlsx', '.ppt', '.pptx'
        }
        self._create_quarantine_directory()
        self._load_malware_signatures()
        print("üîç Real-time Malware Scanner initialized!")
        print(f"   Scan directories: {len(self.scan_directories)}")
        print(f"   File extensions: {len(self.scan_extensions)}")
        print(f"   Suspicious patterns: {len(self.suspicious_patterns)}")

    def _create_quarantine_directory(self):
        """Create quarantine directory if it doesn't exist"""
        try:
            os.makedirs(self.quarantine_dir, exist_ok=True)
            print(f"‚úÖ Quarantine directory created: {self.quarantine_dir}")
        except Exception as e:
            print(f"‚ùå Failed to create quarantine directory: {e}")

    def _load_malware_signatures(self):
        """Load malware signatures from database"""
        # In a real implementation, this would load from a signature database
        # For now, we'll use some common malware patterns
        common_malware_hashes = [
            "d41d8cd98f00b204e9800998ecf8427e",  # Empty file (common in malware)
            "5d41402abc4b2a76b9719d911017c592",  # "hello" (common test)
        ]
        self.malware_signatures.update(common_malware_hashes)
        print(f"‚úÖ Loaded {len(self.malware_signatures)} malware signatures")

    def start_scanning(self):
        """Start real-time malware scanning"""
        if self.scanning_active:
            return
        self.scanning_active = True
        self.scanning_thread = threading.Thread(target=self._scanning_loop, daemon=True)
        self.scanning_thread.start()
        print("üîç Real-time malware scanning started!")

    def stop_scanning(self):
        """Stop real-time malware scanning"""
        self.scanning_active = False
        if self.scanning_thread:
            self.scanning_thread.join(timeout=5)
        print("‚èπÔ∏è Real-time malware scanning stopped!")

    def _scanning_loop(self):
        """Main scanning loop"""
        while self.scanning_active:
            try:
                self._scan_directories()
                time.sleep(10)  # Scan every 10 seconds
            except Exception as e:
                print(f"‚ùå Scanning loop error: {e}")
                self.scan_stats['scan_errors'] += 1
                time.sleep(10)

    def _scan_directories(self):
        """Scan all configured directories for malware"""
        for directory in self.scan_directories:
            if os.path.exists(directory):
                try:
                    self._scan_directory(directory)
                except Exception as e:
                    print(f"‚ùå Error scanning directory {directory}: {e}")
                    self.scan_stats['scan_errors'] += 1

    def _scan_directory(self, directory: str):
        """Scan a specific directory for malware"""
        try:
            for root, dirs, files in os.walk(directory):
                for file in files:
                    file_path = os.path.join(root, file)
                    if self._should_scan_file(file_path):
                        self._scan_file(file_path)
        except Exception as e:
            print(f"‚ùå Error scanning directory {directory}: {e}")

    def _should_scan_file(self, file_path: str) -> bool:
        """Check if a file should be scanned"""
        try:
            # Check file extension
            file_ext = Path(file_path).suffix.lower()
            if file_ext not in self.scan_extensions:
                return False
            
            # Check file size (skip very large files)
            file_size = os.path.getsize(file_path)
            if file_size > 100 * 1024 * 1024:  # Skip files larger than 100MB
                return False
            
            # Check if file is accessible
            if not os.access(file_path, os.R_OK):
                return False
            
            return True
        except Exception:
            return False

    def _scan_file(self, file_path: str):
        """Scan a specific file for malware"""
        try:
            self.scan_stats['files_scanned'] += 1
            
            # Calculate file hash
            file_hash = self._calculate_file_hash(file_path)
            if not file_hash:
                return
            
            # Check against malware signatures
            if file_hash in self.malware_signatures:
                self._handle_malware_detection(file_path, "Known malware signature", file_hash)
                return
            
            # Check file content for suspicious patterns
            suspicious_patterns = self._scan_file_content(file_path)
            if suspicious_patterns:
                self._handle_malware_detection(file_path, f"Suspicious patterns: {', '.join(suspicious_patterns)}", file_hash)
                return
            
            # Check file behavior (if executable)
            if self._is_executable(file_path):
                behavior_analysis = self._analyze_file_behavior(file_path)
                if behavior_analysis['suspicious']:
                    self._handle_malware_detection(file_path, f"Suspicious behavior: {behavior_analysis['reason']}", file_hash)
                    return
            
        except Exception as e:
            print(f"‚ùå Error scanning file {file_path}: {e}")
            self.scan_stats['scan_errors'] += 1

    def _calculate_file_hash(self, file_path: str) -> Optional[str]:
        """Calculate SHA-256 hash of a file"""
        try:
            hash_sha256 = hashlib.sha256()
            with open(file_path, "rb") as f:
                for chunk in iter(lambda: f.read(4096), b""):
                    hash_sha256.update(chunk)
            return hash_sha256.hexdigest()
        except Exception as e:
            print(f"‚ùå Error calculating hash for {file_path}: {e}")
            return None

    def _scan_file_content(self, file_path: str) -> List[str]:
        """Scan file content for suspicious patterns"""
        suspicious_found = []
        try:
            with open(file_path, "rb") as f:
                content = f.read(8192)  # Read first 8KB
                for pattern in self.suspicious_patterns:
                    if pattern in content:
                        suspicious_found.append(pattern.decode('utf-8', errors='ignore'))
        except Exception as e:
            print(f"‚ùå Error scanning content of {file_path}: {e}")
        return suspicious_found

    def _is_executable(self, file_path: str) -> bool:
        """Check if file is executable"""
        try:
            file_ext = Path(file_path).suffix.lower()
            executable_extensions = {'.exe', '.dll', '.sys', '.bat', '.cmd', '.ps1', '.vbs', '.js', '.jar'}
            return file_ext in executable_extensions
        except Exception:
            return False

    def _analyze_file_behavior(self, file_path: str) -> Dict:
        """Analyze file behavior for suspicious activity"""
        try:
            # Check file permissions
            file_stat = os.stat(file_path)
            if file_stat.st_mode & 0o111:  # Executable permission
                return {'suspicious': True, 'reason': 'Executable file'}
            
            # Check file location
            if 'temp' in file_path.lower() or 'tmp' in file_path.lower():
                return {'suspicious': True, 'reason': 'File in temporary directory'}
            
            # Check file name patterns
            filename = os.path.basename(file_path).lower()
            suspicious_names = ['malware', 'virus', 'trojan', 'backdoor', 'keylogger', 'spyware']
            for name in suspicious_names:
                if name in filename:
                    return {'suspicious': True, 'reason': f'Suspicious filename: {name}'}
            
            return {'suspicious': False, 'reason': 'Normal file behavior'}
        except Exception as e:
            print(f"‚ùå Error analyzing file behavior: {e}")
            return {'suspicious': False, 'reason': 'Analysis error'}

    def _handle_malware_detection(self, file_path: str, reason: str, file_hash: str):
        """Handle malware detection"""
        try:
            self.scan_stats['malware_detected'] += 1
            
            # Log the detection
            detection = {
                'timestamp': time.time(),
                'file_path': file_path,
                'reason': reason,
                'file_hash': file_hash,
                'action': 'quarantined'
            }
            self.scan_results.append(detection)
            
            # Quarantine the file
            quarantine_success = self._quarantine_file(file_path, file_hash)
            if quarantine_success:
                self.scan_stats['files_quarantined'] += 1
                print(f"üö® MALWARE DETECTED: {file_path}")
                print(f"   Reason: {reason}")
                print(f"   Hash: {file_hash}")
                print(f"   Action: Quarantined")
            else:
                print(f"‚ùå Failed to quarantine malware: {file_path}")
                
        except Exception as e:
            print(f"‚ùå Error handling malware detection: {e}")

    def _quarantine_file(self, file_path: str, file_hash: str) -> bool:
        """Quarantine a malicious file"""
        try:
            # Create quarantine filename
            filename = os.path.basename(file_path)
            quarantine_filename = f"{file_hash}_{filename}"
            quarantine_path = os.path.join(self.quarantine_dir, quarantine_filename)
            
            # Move file to quarantine
            os.rename(file_path, quarantine_path)
            
            # Create quarantine log
            quarantine_log = {
                'original_path': file_path,
                'quarantine_path': quarantine_path,
                'file_hash': file_hash,
                'quarantine_time': time.time()
            }
            
            log_file = os.path.join(self.quarantine_dir, "quarantine_log.json")
            with open(log_file, "a") as f:
                f.write(json.dumps(quarantine_log) + "\n")
            
            return True
        except Exception as e:
            print(f"‚ùå Error quarantining file: {e}")
            return False

    def scan_file(self, file_path: str) -> Dict:
        """Scan a specific file for malware"""
        try:
            if not os.path.exists(file_path):
                return {'malware_detected': False, 'reason': 'File not found'}
            
            if not self._should_scan_file(file_path):
                return {'malware_detected': False, 'reason': 'File not scannable'}
            
            # Calculate hash
            file_hash = self._calculate_file_hash(file_path)
            if not file_hash:
                return {'malware_detected': False, 'reason': 'Hash calculation failed'}
            
            # Check signatures
            if file_hash in self.malware_signatures:
                return {'malware_detected': True, 'reason': 'Known malware signature', 'file_hash': file_hash}
            
            # Check content
            suspicious_patterns = self._scan_file_content(file_path)
            if suspicious_patterns:
                return {'malware_detected': True, 'reason': f'Suspicious patterns: {suspicious_patterns}', 'file_hash': file_hash}
            
            # Check behavior
            if self._is_executable(file_path):
                behavior = self._analyze_file_behavior(file_path)
                if behavior['suspicious']:
                    return {'malware_detected': True, 'reason': behavior['reason'], 'file_hash': file_hash}
            
            return {'malware_detected': False, 'reason': 'File appears clean', 'file_hash': file_hash}
            
        except Exception as e:
            return {'malware_detected': False, 'reason': f'Scan error: {e}'}

    def get_scan_statistics(self) -> Dict:
        """Get scanning statistics"""
        return {
            'scanning_active': self.scanning_active,
            'files_scanned': self.scan_stats['files_scanned'],
            'malware_detected': self.scan_stats['malware_detected'],
            'files_quarantined': self.scan_stats['files_quarantined'],
            'false_positives': self.scan_stats['false_positives'],
            'scan_errors': self.scan_stats['scan_errors'],
            'quarantine_directory': self.quarantine_dir,
            'scan_directories': len(self.scan_directories),
            'malware_signatures': len(self.malware_signatures)
        }

    def get_recent_detections(self, count: int = 10) -> List[Dict]:
        """Get recent malware detections"""
        return list(self.scan_results)[-count:]

    def restore_file(self, quarantine_filename: str, restore_path: str) -> bool:
        """Restore a file from quarantine"""
        try:
            quarantine_path = os.path.join(self.quarantine_dir, quarantine_filename)
            if not os.path.exists(quarantine_path):
                print(f"‚ùå Quarantined file not found: {quarantine_filename}")
                return False
            
            # Move file back to restore path
            os.rename(quarantine_path, restore_path)
            print(f"‚úÖ File restored: {quarantine_filename} -> {restore_path}")
            return True
        except Exception as e:
            print(f"‚ùå Error restoring file: {e}")
            return False

    def update_signatures(self, new_signatures: List[str]):
        """Update malware signatures"""
        self.malware_signatures.update(new_signatures)
        print(f"‚úÖ Updated malware signatures: {len(new_signatures)} new signatures")

    def add_scan_directory(self, directory: str):
        """Add a directory to scan list"""
        if os.path.exists(directory) and directory not in self.scan_directories:
            self.scan_directories.append(directory)
            print(f"‚úÖ Added scan directory: {directory}")

    def remove_scan_directory(self, directory: str):
        """Remove a directory from scan list"""
        if directory in self.scan_directories:
            self.scan_directories.remove(directory)
            print(f"‚úÖ Removed scan directory: {directory}")
