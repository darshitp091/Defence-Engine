import os
import time
import threading
import subprocess
import tempfile
import shutil
from collections import deque
from typing import Dict, List, Optional, Tuple
import json
import psutil
import hashlib
import socket
import random
import string

class MalwareSandbox:
    def __init__(self):
        self.sandbox_active = False
        self.sandbox_thread = None
        self.sandbox_dir = None
        self.original_env = os.environ.copy()
        self.sandbox_stats = {
            'files_analyzed': 0,
            'malware_detected': 0,
            'sandbox_sessions': 0,
            'analysis_errors': 0
        }
        self.analysis_results = deque(maxlen=1000)
        self.suspicious_activities = deque(maxlen=5000)
        
        # Sandbox configuration
        self.sandbox_config = {
            'max_execution_time': 300,  # 5 minutes
            'max_memory_usage': 512 * 1024 * 1024,  # 512MB
            'max_cpu_usage': 80,  # 80%
            'network_isolation': True,
            'file_system_isolation': True,
            'registry_isolation': True,
            'process_isolation': True
        }
        
        # Malware behavior patterns to monitor
        self.monitored_behaviors = {
            'file_operations': [
                'file_creation', 'file_deletion', 'file_modification',
                'file_encryption', 'file_copying', 'file_moving'
            ],
            'network_operations': [
                'tcp_connections', 'udp_connections', 'dns_queries',
                'http_requests', 'https_requests', 'ftp_connections'
            ],
            'process_operations': [
                'process_creation', 'process_injection', 'process_termination',
                'thread_creation', 'dll_loading', 'service_creation'
            ],
            'registry_operations': [
                'registry_read', 'registry_write', 'registry_delete',
                'startup_modification', 'service_creation'
            ],
            'system_operations': [
                'driver_loading', 'service_creation', 'scheduled_task_creation',
                'user_account_creation', 'log_clearing', 'system_shutdown'
            ]
        }
        
        print("üèñÔ∏è Malware Sandbox initialized!")
        print(f"   Max execution time: {self.sandbox_config['max_execution_time']}s")
        print(f"   Max memory usage: {self.sandbox_config['max_memory_usage'] / (1024*1024)}MB")
        print(f"   Network isolation: {self.sandbox_config['network_isolation']}")

    def create_sandbox_environment(self) -> str:
        """Create isolated sandbox environment"""
        try:
            # Create temporary directory for sandbox
            self.sandbox_dir = tempfile.mkdtemp(prefix="malware_sandbox_")
            
            # Create sandbox subdirectories
            sandbox_dirs = [
                'system', 'temp', 'downloads', 'documents', 'desktop',
                'registry', 'network', 'processes'
            ]
            
            for dir_name in sandbox_dirs:
                os.makedirs(os.path.join(self.sandbox_dir, dir_name), exist_ok=True)
            
            # Create fake system files
            self._create_fake_system_files()
            
            # Set up network isolation
            if self.sandbox_config['network_isolation']:
                self._setup_network_isolation()
            
            print(f"‚úÖ Sandbox environment created: {self.sandbox_dir}")
            return self.sandbox_dir
            
        except Exception as e:
            print(f"‚ùå Failed to create sandbox environment: {e}")
            return None

    def _create_fake_system_files(self):
        """Create fake system files to trick malware"""
        try:
            fake_files = {
                'system32': [
                    'kernel32.dll', 'user32.dll', 'gdi32.dll', 'advapi32.dll',
                    'ntdll.dll', 'ole32.dll', 'oleaut32.dll', 'shell32.dll'
                ],
                'system': [
                    'drivers', 'services', 'registry', 'logs'
                ],
                'temp': [
                    'temp_file_1.tmp', 'temp_file_2.tmp', 'cache_file.cache'
                ]
            }
            
            for category, files in fake_files.items():
                category_dir = os.path.join(self.sandbox_dir, category)
                os.makedirs(category_dir, exist_ok=True)
                
                for file_name in files:
                    file_path = os.path.join(category_dir, file_name)
                    with open(file_path, 'w') as f:
                        f.write(f"# Fake {file_name} file for sandbox\n")
                        f.write(f"# Created at {time.time()}\n")
                        f.write("# This is a sandboxed environment\n")
            
            print("‚úÖ Fake system files created")
            
        except Exception as e:
            print(f"‚ùå Error creating fake system files: {e}")

    def _setup_network_isolation(self):
        """Setup network isolation for sandbox"""
        try:
            # Create fake network configuration
            network_config = {
                'fake_ips': ['192.168.1.100', '192.168.1.101', '192.168.1.102'],
                'fake_domains': ['fake-malware-site.com', 'suspicious-domain.net'],
                'fake_ports': [80, 443, 22, 21, 25, 53, 110, 143, 993, 995]
            }
            
            # Save network config for sandbox
            config_file = os.path.join(self.sandbox_dir, 'network_config.json')
            with open(config_file, 'w') as f:
                json.dump(network_config, f, indent=2)
            
            print("‚úÖ Network isolation configured")
            
        except Exception as e:
            print(f"‚ùå Error setting up network isolation: {e}")

    def analyze_file_in_sandbox(self, file_path: str) -> Dict:
        """Analyze a file in the sandbox environment"""
        try:
            if not os.path.exists(file_path):
                return {'error': 'File not found'}
            
            # Create sandbox environment
            sandbox_path = self.create_sandbox_environment()
            if not sandbox_path:
                return {'error': 'Failed to create sandbox environment'}
            
            # Copy file to sandbox
            sandbox_file_path = os.path.join(sandbox_path, 'temp', os.path.basename(file_path))
            shutil.copy2(file_path, sandbox_file_path)
            
            # Start sandbox analysis
            analysis_result = self._run_sandbox_analysis(sandbox_file_path, sandbox_path)
            
            # Cleanup sandbox
            self._cleanup_sandbox(sandbox_path)
            
            return analysis_result
            
        except Exception as e:
            return {'error': f'Sandbox analysis failed: {e}'}

    def _run_sandbox_analysis(self, file_path: str, sandbox_path: str) -> Dict:
        """Run analysis in sandbox environment"""
        try:
            self.sandbox_stats['sandbox_sessions'] += 1
            self.sandbox_stats['files_analyzed'] += 1
            
            analysis_start_time = time.time()
            analysis_result = {
                'file_path': file_path,
                'sandbox_path': sandbox_path,
                'analysis_start': analysis_start_time,
                'behaviors_detected': [],
                'suspicious_activities': [],
                'network_activity': [],
                'file_operations': [],
                'process_operations': [],
                'threat_level': 'low',
                'malware_family': 'unknown',
                'analysis_duration': 0
            }
            
            # Monitor file execution
            if self._is_executable_file(file_path):
                execution_result = self._monitor_file_execution(file_path, sandbox_path)
                analysis_result.update(execution_result)
            
            # Analyze file content
            content_analysis = self._analyze_file_content(file_path)
            analysis_result['content_analysis'] = content_analysis
            
            # Check for malware signatures
            signature_analysis = self._check_malware_signatures(file_path)
            analysis_result['signature_analysis'] = signature_analysis
            
            # Calculate threat level
            analysis_result['threat_level'] = self._calculate_threat_level(analysis_result)
            
            # Identify malware family
            analysis_result['malware_family'] = self._identify_malware_family(analysis_result)
            
            analysis_result['analysis_duration'] = time.time() - analysis_start_time
            
            # Store analysis result
            self.analysis_results.append(analysis_result)
            
            if analysis_result['threat_level'] in ['high', 'critical']:
                self.sandbox_stats['malware_detected'] += 1
            
            return analysis_result
            
        except Exception as e:
            return {'error': f'Sandbox analysis error: {e}'}

    def _is_executable_file(self, file_path: str) -> bool:
        """Check if file is executable"""
        try:
            file_ext = os.path.splitext(file_path)[1].lower()
            executable_extensions = {'.exe', '.dll', '.sys', '.bat', '.cmd', '.ps1', '.vbs', '.js', '.jar'}
            return file_ext in executable_extensions
        except Exception:
            return False

    def _monitor_file_execution(self, file_path: str, sandbox_path: str) -> Dict:
        """Monitor file execution in sandbox"""
        try:
            execution_result = {
                'execution_successful': False,
                'execution_time': 0,
                'memory_usage': 0,
                'cpu_usage': 0,
                'network_connections': [],
                'file_operations': [],
                'process_operations': [],
                'suspicious_behaviors': []
            }
            
            # Start monitoring thread
            monitoring_thread = threading.Thread(
                target=self._monitor_execution,
                args=(file_path, sandbox_path, execution_result),
                daemon=True
            )
            monitoring_thread.start()
            
            # Execute file in sandbox
            try:
                start_time = time.time()
                
                # Change to sandbox directory
                original_cwd = os.getcwd()
                os.chdir(sandbox_path)
                
                # Execute file
                if file_path.endswith('.exe'):
                    result = subprocess.run([file_path], 
                                          capture_output=True, 
                                          timeout=self.sandbox_config['max_execution_time'],
                                          cwd=sandbox_path)
                else:
                    # For non-executable files, try to open with default program
                    result = subprocess.run(['start', file_path], 
                                          capture_output=True, 
                                          timeout=self.sandbox_config['max_execution_time'],
                                          cwd=sandbox_path, shell=True)
                
                execution_result['execution_successful'] = True
                execution_result['execution_time'] = time.time() - start_time
                
                # Restore original directory
                os.chdir(original_cwd)
                
            except subprocess.TimeoutExpired:
                execution_result['execution_successful'] = False
                execution_result['timeout'] = True
            except Exception as e:
                execution_result['execution_successful'] = False
                execution_result['error'] = str(e)
            
            # Wait for monitoring to complete
            monitoring_thread.join(timeout=10)
            
            return execution_result
            
        except Exception as e:
            return {'error': f'Execution monitoring failed: {e}'}

    def _monitor_execution(self, file_path: str, sandbox_path: str, execution_result: Dict):
        """Monitor execution in background thread"""
        try:
            start_time = time.time()
            max_monitoring_time = self.sandbox_config['max_execution_time']
            
            while time.time() - start_time < max_monitoring_time:
                # Monitor system resources
                self._monitor_system_resources(execution_result)
                
                # Monitor network activity
                self._monitor_network_activity(execution_result)
                
                # Monitor file operations
                self._monitor_file_operations(sandbox_path, execution_result)
                
                # Monitor process activity
                self._monitor_process_activity(execution_result)
                
                time.sleep(1)  # Monitor every second
                
        except Exception as e:
            print(f"‚ùå Execution monitoring error: {e}")

    def _monitor_system_resources(self, execution_result: Dict):
        """Monitor system resource usage"""
        try:
            # Monitor CPU usage
            cpu_percent = psutil.cpu_percent(interval=1)
            if cpu_percent > execution_result.get('cpu_usage', 0):
                execution_result['cpu_usage'] = cpu_percent
            
            # Monitor memory usage
            memory = psutil.virtual_memory()
            if memory.percent > execution_result.get('memory_usage', 0):
                execution_result['memory_usage'] = memory.percent
            
            # Check for suspicious resource usage
            if cpu_percent > self.sandbox_config['max_cpu_usage']:
                execution_result['suspicious_behaviors'].append('high_cpu_usage')
            
            if memory.percent > 80:
                execution_result['suspicious_behaviors'].append('high_memory_usage')
                
        except Exception as e:
            print(f"‚ùå System resource monitoring error: {e}")

    def _monitor_network_activity(self, execution_result: Dict):
        """Monitor network activity"""
        try:
            # Get network connections
            connections = psutil.net_connections(kind='inet')
            
            for conn in connections:
                if conn.status == 'ESTABLISHED':
                    connection_info = {
                        'local_address': conn.laddr,
                        'remote_address': conn.raddr,
                        'protocol': conn.type,
                        'status': conn.status
                    }
                    execution_result['network_connections'].append(connection_info)
                    
                    # Check for suspicious network activity
                    if conn.raddr and conn.raddr.port > 49152:
                        execution_result['suspicious_behaviors'].append('unusual_port_usage')
                    
                    if self._is_suspicious_remote_address(conn.raddr.ip if conn.raddr else None):
                        execution_result['suspicious_behaviors'].append('suspicious_remote_connection')
                        
        except Exception as e:
            print(f"‚ùå Network activity monitoring error: {e}")

    def _monitor_file_operations(self, sandbox_path: str, execution_result: Dict):
        """Monitor file operations in sandbox"""
        try:
            # Monitor file changes in sandbox
            for root, dirs, files in os.walk(sandbox_path):
                for file in files:
                    file_path = os.path.join(root, file)
                    try:
                        stat = os.stat(file_path)
                        if time.time() - stat.st_mtime < 5:  # Modified in last 5 seconds
                            file_operation = {
                                'file_path': file_path,
                                'operation': 'modified',
                                'timestamp': time.time(),
                                'size': stat.st_size
                            }
                            execution_result['file_operations'].append(file_operation)
                            
                            # Check for suspicious file operations
                            if file_path.endswith('.encrypted'):
                                execution_result['suspicious_behaviors'].append('file_encryption')
                            elif file_path.endswith('.locked'):
                                execution_result['suspicious_behaviors'].append('file_locking')
                                
                    except Exception:
                        continue
                        
        except Exception as e:
            print(f"‚ùå File operations monitoring error: {e}")

    def _monitor_process_activity(self, execution_result: Dict):
        """Monitor process activity"""
        try:
            # Get current processes
            processes = list(psutil.process_iter(['pid', 'name', 'cpu_percent', 'memory_percent']))
            
            for proc in processes:
                try:
                    proc_info = proc.info
                    if proc_info['cpu_percent'] > 50 or proc_info['memory_percent'] > 30:
                        process_operation = {
                            'pid': proc_info['pid'],
                            'name': proc_info['name'],
                            'cpu_percent': proc_info['cpu_percent'],
                            'memory_percent': proc_info['memory_percent'],
                            'timestamp': time.time()
                        }
                        execution_result['process_operations'].append(process_operation)
                        
                        # Check for suspicious process behavior
                        if proc_info['name'].lower() in ['malware', 'virus', 'trojan']:
                            execution_result['suspicious_behaviors'].append('suspicious_process_name')
                            
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    continue
                    
        except Exception as e:
            print(f"‚ùå Process activity monitoring error: {e}")

    def _is_suspicious_remote_address(self, ip: str) -> bool:
        """Check if remote IP address is suspicious"""
        if not ip:
            return False
        
        # Check against known malicious IP ranges
        suspicious_ranges = [
            '10.0.0.0/8',
            '192.168.0.0/16',
            '172.16.0.0/12'
        ]
        
        # In a real implementation, you'd check against threat intelligence feeds
        return False  # Simplified for demo

    def _analyze_file_content(self, file_path: str) -> Dict:
        """Analyze file content for suspicious patterns"""
        try:
            content_analysis = {
                'file_size': os.path.getsize(file_path),
                'file_type': self._detect_file_type(file_path),
                'suspicious_patterns': [],
                'entropy_score': 0,
                'encryption_indicators': False
            }
            
            # Read file content
            with open(file_path, 'rb') as f:
                content = f.read(8192)  # Read first 8KB
                
                # Check for suspicious patterns
                suspicious_patterns = [
                    b'MZ',  # PE header
                    b'ELF',  # ELF header
                    b'<script',  # JavaScript
                    b'eval(',  # JavaScript eval
                    b'base64_decode',  # PHP base64 decode
                    b'shell_exec',  # PHP shell execution
                    b'cmd.exe',  # Windows command
                    b'powershell',  # PowerShell
                ]
                
                for pattern in suspicious_patterns:
                    if pattern in content:
                        content_analysis['suspicious_patterns'].append(pattern.decode('utf-8', errors='ignore'))
                
                # Calculate entropy
                content_analysis['entropy_score'] = self._calculate_entropy(content)
                
                # Check for encryption indicators
                if content_analysis['entropy_score'] > 7.5:
                    content_analysis['encryption_indicators'] = True
                    
            return content_analysis
            
        except Exception as e:
            return {'error': f'Content analysis failed: {e}'}

    def _detect_file_type(self, file_path: str) -> str:
        """Detect file type"""
        try:
            file_ext = os.path.splitext(file_path)[1].lower()
            if file_ext == '.exe':
                return 'executable'
            elif file_ext == '.dll':
                return 'dynamic_library'
            elif file_ext in ['.bat', '.cmd']:
                return 'batch_script'
            elif file_ext == '.ps1':
                return 'powershell_script'
            elif file_ext == '.vbs':
                return 'vbscript'
            elif file_ext == '.js':
                return 'javascript'
            else:
                return 'unknown'
        except Exception:
            return 'unknown'

    def _calculate_entropy(self, data: bytes) -> float:
        """Calculate entropy of data"""
        try:
            if not data:
                return 0.0
            
            # Count byte frequencies
            byte_counts = [0] * 256
            for byte in data:
                byte_counts[byte] += 1
            
            # Calculate entropy
            entropy = 0.0
            data_len = len(data)
            for count in byte_counts:
                if count > 0:
                    probability = count / data_len
                    entropy -= probability * (probability.bit_length() - 1)
            
            return entropy
        except Exception:
            return 0.0

    def _check_malware_signatures(self, file_path: str) -> Dict:
        """Check file against malware signatures"""
        try:
            # Calculate file hash
            file_hash = self._calculate_file_hash(file_path)
            
            # Check against known malware signatures
            known_malware_hashes = [
                'd41d8cd98f00b204e9800998ecf8427e',  # Empty file
                '5d41402abc4b2a76b9719d911017c592',  # "hello"
            ]
            
            signature_match = file_hash in known_malware_hashes
            
            return {
                'file_hash': file_hash,
                'signature_match': signature_match,
                'known_malware': signature_match
            }
            
        except Exception as e:
            return {'error': f'Signature check failed: {e}'}

    def _calculate_file_hash(self, file_path: str) -> str:
        """Calculate SHA-256 hash of file"""
        try:
            hash_sha256 = hashlib.sha256()
            with open(file_path, "rb") as f:
                for chunk in iter(lambda: f.read(4096), b""):
                    hash_sha256.update(chunk)
            return hash_sha256.hexdigest()
        except Exception:
            return ""

    def _calculate_threat_level(self, analysis_result: Dict) -> str:
        """Calculate threat level based on analysis results"""
        try:
            threat_score = 0
            
            # Check suspicious behaviors
            suspicious_behaviors = analysis_result.get('suspicious_behaviors', [])
            threat_score += len(suspicious_behaviors) * 10
            
            # Check content analysis
            content_analysis = analysis_result.get('content_analysis', {})
            if content_analysis.get('encryption_indicators'):
                threat_score += 20
            if content_analysis.get('suspicious_patterns'):
                threat_score += len(content_analysis['suspicious_patterns']) * 5
            
            # Check signature analysis
            signature_analysis = analysis_result.get('signature_analysis', {})
            if signature_analysis.get('known_malware'):
                threat_score += 50
            
            # Determine threat level
            if threat_score >= 80:
                return 'critical'
            elif threat_score >= 60:
                return 'high'
            elif threat_score >= 40:
                return 'medium'
            else:
                return 'low'
                
        except Exception:
            return 'low'

    def _identify_malware_family(self, analysis_result: Dict) -> str:
        """Identify malware family based on analysis results"""
        try:
            suspicious_behaviors = analysis_result.get('suspicious_behaviors', [])
            content_analysis = analysis_result.get('content_analysis', {})
            
            # Check for ransomware indicators
            if 'file_encryption' in suspicious_behaviors or content_analysis.get('encryption_indicators'):
                return 'crypto_ransomware'
            
            # Check for trojan indicators
            if 'suspicious_process_name' in suspicious_behaviors:
                return 'trojan_horse'
            
            # Check for botnet indicators
            if 'high_network_activity' in suspicious_behaviors:
                return 'botnet'
            
            # Check for spyware indicators
            if 'high_file_activity' in suspicious_behaviors:
                return 'spyware'
            
            return 'unknown'
            
        except Exception:
            return 'unknown'

    def _cleanup_sandbox(self, sandbox_path: str):
        """Clean up sandbox environment"""
        try:
            if os.path.exists(sandbox_path):
                shutil.rmtree(sandbox_path)
                print(f"‚úÖ Sandbox cleaned up: {sandbox_path}")
        except Exception as e:
            print(f"‚ùå Sandbox cleanup error: {e}")

    def get_sandbox_statistics(self) -> Dict:
        """Get sandbox statistics"""
        return {
            'sandbox_active': self.sandbox_active,
            'files_analyzed': self.sandbox_stats['files_analyzed'],
            'malware_detected': self.sandbox_stats['malware_detected'],
            'sandbox_sessions': self.sandbox_stats['sandbox_sessions'],
            'analysis_errors': self.sandbox_stats['analysis_errors'],
            'analysis_results_size': len(self.analysis_results),
            'suspicious_activities_size': len(self.suspicious_activities)
        }

    def get_recent_analyses(self, count: int = 10) -> List[Dict]:
        """Get recent analysis results"""
        return list(self.analysis_results)[-count:]

    def start_sandbox_monitoring(self):
        """Start continuous sandbox monitoring"""
        if self.sandbox_active:
            return
        self.sandbox_active = True
        self.sandbox_thread = threading.Thread(target=self._sandbox_monitoring_loop, daemon=True)
        self.sandbox_thread.start()
        print("üèñÔ∏è Sandbox monitoring started!")

    def stop_sandbox_monitoring(self):
        """Stop sandbox monitoring"""
        self.sandbox_active = False
        if self.sandbox_thread:
            self.sandbox_thread.join(timeout=5)
        print("‚èπÔ∏è Sandbox monitoring stopped!")

    def _sandbox_monitoring_loop(self):
        """Continuous sandbox monitoring loop"""
        while self.sandbox_active:
            try:
                # Monitor for new files to analyze
                self._monitor_new_files()
                time.sleep(10)  # Check every 10 seconds
            except Exception as e:
                print(f"‚ùå Sandbox monitoring error: {e}")
                time.sleep(10)

    def _monitor_new_files(self):
        """Monitor for new files to analyze"""
        try:
            # Monitor common download directories
            monitor_dirs = [
                os.path.expanduser("~\\Downloads"),
                os.path.expanduser("~\\Desktop"),
                "C:\\Windows\\Temp",
                "C:\\Temp"
            ]
            
            for directory in monitor_dirs:
                if os.path.exists(directory):
                    for root, dirs, files in os.walk(directory):
                        for file in files:
                            file_path = os.path.join(root, file)
                            if self._should_analyze_file(file_path):
                                print(f"üîç Analyzing new file: {file_path}")
                                analysis_result = self.analyze_file_in_sandbox(file_path)
                                if analysis_result.get('threat_level') in ['high', 'critical']:
                                    print(f"üö® MALWARE DETECTED: {file_path}")
                                    
        except Exception as e:
            print(f"‚ùå New file monitoring error: {e}")

    def _should_analyze_file(self, file_path: str) -> bool:
        """Check if file should be analyzed"""
        try:
            # Check file extension
            file_ext = os.path.splitext(file_path)[1].lower()
            analyzable_extensions = {'.exe', '.dll', '.sys', '.bat', '.cmd', '.ps1', '.vbs', '.js', '.jar'}
            if file_ext not in analyzable_extensions:
                return False
            
            # Check file size
            file_size = os.path.getsize(file_path)
            if file_size > 100 * 1024 * 1024:  # Skip files larger than 100MB
                return False
            
            # Check if file is accessible
            if not os.access(file_path, os.R_OK):
                return False
            
            return True
        except Exception:
            return False
