import time
import threading
import psutil
import os
import ctypes
from collections import deque
from typing import Dict, List, Optional, Tuple
import json
import hashlib
import struct
import mmap

class MemoryProtector:
    def __init__(self):
        self.protection_active = False
        self.protection_thread = None
        self.memory_regions = deque(maxlen=10000)
        self.memory_violations = deque(maxlen=5000)
        self.injection_attempts = deque(maxlen=1000)
        
        # Memory protection configuration
        self.protection_config = {
            'monitor_heap': True,
            'monitor_stack': True,
            'monitor_executable_memory': True,
            'monitor_dll_injection': True,
            'monitor_code_injection': True,
            'monitor_memory_corruption': True,
            'max_memory_usage': 80,  # 80% of system memory
            'protection_level': 'high'  # low, medium, high, maximum
        }
        
        # Memory protection patterns
        self.memory_patterns = {
            'shellcode_patterns': [
                b'\x48\x31\xc0',  # xor rax, rax
                b'\x48\x31\xd2',  # xor rdx, rdx
                b'\x48\x31\xf6',  # xor rsi, rsi
                b'\x48\x31\xff',  # xor rdi, rdi
                b'\x4d\x31\xc0',  # xor r8, r8
                b'\x4d\x31\xc9',  # xor r9, r9
                b'\x4d\x31\xd2',  # xor r10, r10
                b'\x4d\x31\xdb',  # xor r11, r11
                b'\x4d\x31\xe4',  # xor r12, r12
                b'\x4d\x31\xed',  # xor r13, r13
                b'\x4d\x31\xf6',  # xor r14, r14
                b'\x4d\x31\xff',  # xor r15, r15
            ],
            'injection_patterns': [
                b'CreateRemoteThread',
                b'WriteProcessMemory',
                b'VirtualAllocEx',
                b'OpenProcess',
                b'NtCreateThreadEx',
                b'RtlCreateUserThread',
                b'SetWindowsHookEx',
                b'QueueUserAPC'
            ],
            'malware_patterns': [
                b'MZ',  # PE header
                b'This program cannot be run in DOS mode',
                b'Microsoft Visual C++',
                b'Borland C++',
                b'Delphi'
            ]
        }
        
        # Memory protection statistics
        self.protection_stats = {
            'memory_regions_monitored': 0,
            'injection_attempts_blocked': 0,
            'memory_violations_detected': 0,
            'shellcode_detected': 0,
            'dll_injections_blocked': 0,
            'code_injections_blocked': 0,
            'protection_errors': 0
        }
        
        print("üõ°Ô∏è Memory Protector initialized!")
        print(f"   Protection level: {self.protection_config['protection_level']}")
        print(f"   Max memory usage: {self.protection_config['max_memory_usage']}%")
        print(f"   Shellcode patterns: {len(self.memory_patterns['shellcode_patterns'])}")
        print(f"   Injection patterns: {len(self.memory_patterns['injection_patterns'])}")

    def start_memory_protection(self):
        """Start memory protection monitoring"""
        if self.protection_active:
            return
        self.protection_active = True
        self.protection_thread = threading.Thread(target=self._protection_loop, daemon=True)
        self.protection_thread.start()
        print("üõ°Ô∏è Memory protection started!")

    def stop_memory_protection(self):
        """Stop memory protection monitoring"""
        self.protection_active = False
        if self.protection_thread:
            self.protection_thread.join(timeout=5)
        print("‚èπÔ∏è Memory protection stopped!")

    def _protection_loop(self):
        """Main memory protection loop"""
        while self.protection_active:
            try:
                self._monitor_memory_regions()
                self._monitor_memory_usage()
                self._monitor_process_memory()
                self._scan_for_shellcode()
                self._monitor_dll_injections()
                self._monitor_code_injections()
                time.sleep(2)  # Monitor every 2 seconds
            except Exception as e:
                print(f"‚ùå Memory protection error: {e}")
                self.protection_stats['protection_errors'] += 1
                time.sleep(2)

    def _monitor_memory_regions(self):
        """Monitor memory regions for suspicious activity"""
        try:
            # Get system memory information
            memory_info = psutil.virtual_memory()
            
            # Monitor memory regions
            for proc in psutil.process_iter(['pid', 'name', 'memory_info']):
                try:
                    proc_info = proc.info
                    if proc_info['pid'] == 0:  # Skip system processes
                        continue
                    
                    memory_data = {
                        'timestamp': time.time(),
                        'pid': proc_info['pid'],
                        'name': proc_info['name'],
                        'rss': proc_info['memory_info'].rss,
                        'vms': proc_info['memory_info'].vms,
                        'percent': proc_info['memory_info'].percent
                    }
                    
                    self.memory_regions.append(memory_data)
                    self.protection_stats['memory_regions_monitored'] += 1
                    
                    # Check for suspicious memory usage
                    self._check_memory_anomalies(memory_data)
                    
                except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
                    continue
                    
        except Exception as e:
            print(f"‚ùå Memory region monitoring error: {e}")

    def _monitor_memory_usage(self):
        """Monitor overall system memory usage"""
        try:
            memory_info = psutil.virtual_memory()
            
            # Check if memory usage exceeds threshold
            if memory_info.percent > self.protection_config['max_memory_usage']:
                violation = {
                    'timestamp': time.time(),
                    'type': 'high_memory_usage',
                    'usage_percent': memory_info.percent,
                    'threshold': self.protection_config['max_memory_usage'],
                    'available': memory_info.available,
                    'used': memory_info.used
                }
                
                self.memory_violations.append(violation)
                self.protection_stats['memory_violations_detected'] += 1
                
                print(f"üö® HIGH MEMORY USAGE DETECTED: {memory_info.percent:.1f}%")
                print(f"   Available: {memory_info.available / (1024**3):.1f} GB")
                print(f"   Used: {memory_info.used / (1024**3):.1f} GB")
                
        except Exception as e:
            print(f"‚ùå Memory usage monitoring error: {e}")

    def _monitor_process_memory(self):
        """Monitor individual process memory usage"""
        try:
            for proc in psutil.process_iter(['pid', 'name', 'memory_info', 'cpu_percent']):
                try:
                    proc_info = proc.info
                    if proc_info['pid'] == 0:
                        continue
                    
                    memory_info = proc_info['memory_info']
                    cpu_percent = proc_info['cpu_percent']
                    
                    # Check for suspicious memory patterns
                    if memory_info.percent > 50:  # Process using more than 50% of system memory
                        violation = {
                            'timestamp': time.time(),
                            'type': 'high_process_memory',
                            'pid': proc_info['pid'],
                            'name': proc_info['name'],
                            'memory_percent': memory_info.percent,
                            'rss': memory_info.rss,
                            'vms': memory_info.vms
                        }
                        
                        self.memory_violations.append(violation)
                        self.protection_stats['memory_violations_detected'] += 1
                        
                        print(f"üö® HIGH PROCESS MEMORY: {proc_info['name']} (PID: {proc_info['pid']})")
                        print(f"   Memory usage: {memory_info.percent:.1f}%")
                        print(f"   RSS: {memory_info.rss / (1024**2):.1f} MB")
                        print(f"   VMS: {memory_info.vms / (1024**2):.1f} MB")
                    
                    # Check for memory + CPU correlation (potential mining)
                    if memory_info.percent > 30 and cpu_percent > 80:
                        violation = {
                            'timestamp': time.time(),
                            'type': 'suspicious_memory_cpu_correlation',
                            'pid': proc_info['pid'],
                            'name': proc_info['name'],
                            'memory_percent': memory_info.percent,
                            'cpu_percent': cpu_percent
                        }
                        
                        self.memory_violations.append(violation)
                        self.protection_stats['memory_violations_detected'] += 1
                        
                        print(f"üö® SUSPICIOUS MEMORY+CPU CORRELATION: {proc_info['name']} (PID: {proc_info['pid']})")
                        print(f"   Memory: {memory_info.percent:.1f}%, CPU: {cpu_percent:.1f}%")
                        
                except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
                    continue
                    
        except Exception as e:
            print(f"‚ùå Process memory monitoring error: {e}")

    def _scan_for_shellcode(self):
        """Scan memory for shellcode patterns"""
        try:
            # This is a simplified implementation
            # In a real scenario, you'd use more sophisticated memory scanning techniques
            
            for proc in psutil.process_iter(['pid', 'name', 'memory_info']):
                try:
                    proc_info = proc.info
                    if proc_info['pid'] == 0:
                        continue
                    
                    # Check process memory for shellcode patterns
                    # This is a simplified check - real implementation would be more complex
                    memory_info = proc_info['memory_info']
                    
                    # Simulate shellcode detection based on memory patterns
                    if memory_info.percent > 20:  # High memory usage might indicate shellcode
                        # Check for shellcode patterns in process memory
                        shellcode_detected = self._detect_shellcode_patterns(proc_info)
                        
                        if shellcode_detected:
                            detection = {
                                'timestamp': time.time(),
                                'type': 'shellcode_detected',
                                'pid': proc_info['pid'],
                                'name': proc_info['name'],
                                'patterns_found': shellcode_detected['patterns'],
                                'confidence': shellcode_detected['confidence']
                            }
                            
                            self.injection_attempts.append(detection)
                            self.protection_stats['shellcode_detected'] += 1
                            
                            print(f"üö® SHELLCODE DETECTED: {proc_info['name']} (PID: {proc_info['pid']})")
                            print(f"   Patterns: {shellcode_detected['patterns']}")
                            print(f"   Confidence: {shellcode_detected['confidence']:.1f}%")
                            
                except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
                    continue
                    
        except Exception as e:
            print(f"‚ùå Shellcode scanning error: {e}")

    def _detect_shellcode_patterns(self, proc_info: Dict) -> Optional[Dict]:
        """Detect shellcode patterns in process memory"""
        try:
            # This is a simplified implementation
            # Real implementation would use memory scanning APIs
            
            patterns_found = []
            confidence = 0.0
            
            # Simulate pattern detection based on process characteristics
            if proc_info['name'].lower() in ['cmd.exe', 'powershell.exe', 'wscript.exe']:
                patterns_found.append('suspicious_process')
                confidence += 30.0
            
            if proc_info['memory_info'].percent > 30:
                patterns_found.append('high_memory_usage')
                confidence += 25.0
            
            # Check for shellcode patterns (simplified)
            for pattern in self.memory_patterns['shellcode_patterns']:
                # In real implementation, you'd scan process memory for these patterns
                if len(pattern) > 0:  # Simplified check
                    patterns_found.append('shellcode_pattern')
                    confidence += 15.0
                    break
            
            if confidence > 50.0:
                return {
                    'patterns': patterns_found,
                    'confidence': min(confidence, 100.0)
                }
            
            return None
            
        except Exception as e:
            print(f"‚ùå Shellcode pattern detection error: {e}")
            return None

    def _monitor_dll_injections(self):
        """Monitor for DLL injection attempts"""
        try:
            # Monitor for suspicious DLL loading patterns
            for proc in psutil.process_iter(['pid', 'name', 'memory_info']):
                try:
                    proc_info = proc.info
                    if proc_info['pid'] == 0:
                        continue
                    
                    # Check for DLL injection patterns
                    dll_injection = self._detect_dll_injection(proc_info)
                    
                    if dll_injection:
                        injection = {
                            'timestamp': time.time(),
                            'type': 'dll_injection',
                            'pid': proc_info['pid'],
                            'name': proc_info['name'],
                            'injection_method': dll_injection['method'],
                            'confidence': dll_injection['confidence']
                        }
                        
                        self.injection_attempts.append(injection)
                        self.protection_stats['dll_injections_blocked'] += 1
                        
                        print(f"üö® DLL INJECTION DETECTED: {proc_info['name']} (PID: {proc_info['pid']})")
                        print(f"   Method: {dll_injection['method']}")
                        print(f"   Confidence: {dll_injection['confidence']:.1f}%")
                        
                except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
                    continue
                    
        except Exception as e:
            print(f"‚ùå DLL injection monitoring error: {e}")

    def _detect_dll_injection(self, proc_info: Dict) -> Optional[Dict]:
        """Detect DLL injection attempts"""
        try:
            # This is a simplified implementation
            # Real implementation would monitor API calls and memory operations
            
            injection_indicators = []
            confidence = 0.0
            
            # Check for suspicious process names
            suspicious_names = ['malware', 'virus', 'trojan', 'backdoor', 'keylogger']
            if any(name in proc_info['name'].lower() for name in suspicious_names):
                injection_indicators.append('suspicious_process_name')
                confidence += 40.0
            
            # Check for high memory usage (potential injection)
            if proc_info['memory_info'].percent > 40:
                injection_indicators.append('high_memory_usage')
                confidence += 30.0
            
            # Check for injection patterns (simplified)
            for pattern in self.memory_patterns['injection_patterns']:
                # In real implementation, you'd check for these API calls
                if len(pattern) > 0:  # Simplified check
                    injection_indicators.append('injection_api_call')
                    confidence += 20.0
                    break
            
            if confidence > 60.0:
                return {
                    'method': 'detected_injection',
                    'confidence': min(confidence, 100.0)
                }
            
            return None
            
        except Exception as e:
            print(f"‚ùå DLL injection detection error: {e}")
            return None

    def _monitor_code_injections(self):
        """Monitor for code injection attempts"""
        try:
            # Monitor for code injection patterns
            for proc in psutil.process_iter(['pid', 'name', 'memory_info']):
                try:
                    proc_info = proc.info
                    if proc_info['pid'] == 0:
                        continue
                    
                    # Check for code injection patterns
                    code_injection = self._detect_code_injection(proc_info)
                    
                    if code_injection:
                        injection = {
                            'timestamp': time.time(),
                            'type': 'code_injection',
                            'pid': proc_info['pid'],
                            'name': proc_info['name'],
                            'injection_method': code_injection['method'],
                            'confidence': code_injection['confidence']
                        }
                        
                        self.injection_attempts.append(injection)
                        self.protection_stats['code_injections_blocked'] += 1
                        
                        print(f"üö® CODE INJECTION DETECTED: {proc_info['name']} (PID: {proc_info['pid']})")
                        print(f"   Method: {code_injection['method']}")
                        print(f"   Confidence: {code_injection['confidence']:.1f}%")
                        
                except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
                    continue
                    
        except Exception as e:
            print(f"‚ùå Code injection monitoring error: {e}")

    def _detect_code_injection(self, proc_info: Dict) -> Optional[Dict]:
        """Detect code injection attempts"""
        try:
            # This is a simplified implementation
            # Real implementation would monitor memory operations and API calls
            
            injection_indicators = []
            confidence = 0.0
            
            # Check for suspicious process behavior
            if proc_info['memory_info'].percent > 50:
                injection_indicators.append('high_memory_usage')
                confidence += 35.0
            
            # Check for code injection patterns
            for pattern in self.memory_patterns['injection_patterns']:
                # In real implementation, you'd check for these API calls
                if len(pattern) > 0:  # Simplified check
                    injection_indicators.append('injection_api_call')
                    confidence += 25.0
                    break
            
            # Check for malware patterns
            for pattern in self.memory_patterns['malware_patterns']:
                # In real implementation, you'd scan process memory
                if len(pattern) > 0:  # Simplified check
                    injection_indicators.append('malware_pattern')
                    confidence += 20.0
                    break
            
            if confidence > 70.0:
                return {
                    'method': 'detected_code_injection',
                    'confidence': min(confidence, 100.0)
                }
            
            return None
            
        except Exception as e:
            print(f"‚ùå Code injection detection error: {e}")
            return None

    def protect_memory_region(self, start_address: int, size: int, protection_type: str = "read") -> bool:
        """Protect a specific memory region"""
        try:
            # This is a simplified implementation
            # Real implementation would use Windows API or similar
            
            protection_info = {
                'timestamp': time.time(),
                'start_address': start_address,
                'size': size,
                'protection_type': protection_type,
                'status': 'protected'
            }
            
            print(f"üõ°Ô∏è Memory region protected: 0x{start_address:x} ({size} bytes)")
            print(f"   Protection type: {protection_type}")
            
            return True
            
        except Exception as e:
            print(f"‚ùå Memory region protection error: {e}")
            return False

    def scan_memory_for_malware(self, pid: int) -> Dict:
        """Scan process memory for malware patterns"""
        try:
            proc = psutil.Process(pid)
            proc_info = {
                'pid': pid,
                'name': proc.name(),
                'memory_info': proc.memory_info(),
                'cpu_percent': proc.cpu_percent()
            }
            
            # Scan for malware patterns
            malware_patterns = self._scan_process_memory(proc_info)
            
            # Calculate threat level
            threat_level = self._calculate_memory_threat_level(malware_patterns)
            
            return {
                'process_info': proc_info,
                'malware_patterns': malware_patterns,
                'threat_level': threat_level,
                'scan_timestamp': time.time()
            }
            
        except Exception as e:
            return {'error': f'Memory scan failed: {e}'}

    def _scan_process_memory(self, proc_info: Dict) -> Dict:
        """Scan process memory for malware patterns"""
        try:
            patterns_found = {
                'shellcode_patterns': [],
                'injection_patterns': [],
                'malware_patterns': [],
                'suspicious_behavior': []
            }
            
            # Check for shellcode patterns
            for pattern in self.memory_patterns['shellcode_patterns']:
                # In real implementation, you'd scan process memory
                if len(pattern) > 0:  # Simplified check
                    patterns_found['shellcode_patterns'].append(pattern.hex())
            
            # Check for injection patterns
            for pattern in self.memory_patterns['injection_patterns']:
                # In real implementation, you'd check for API calls
                if len(pattern) > 0:  # Simplified check
                    patterns_found['injection_patterns'].append(pattern.decode('utf-8', errors='ignore'))
            
            # Check for malware patterns
            for pattern in self.memory_patterns['malware_patterns']:
                # In real implementation, you'd scan process memory
                if len(pattern) > 0:  # Simplified check
                    patterns_found['malware_patterns'].append(pattern.decode('utf-8', errors='ignore'))
            
            # Check for suspicious behavior
            if proc_info['memory_info'].percent > 50:
                patterns_found['suspicious_behavior'].append('high_memory_usage')
            
            if proc_info['cpu_percent'] > 80:
                patterns_found['suspicious_behavior'].append('high_cpu_usage')
            
            return patterns_found
            
        except Exception as e:
            return {'error': f'Memory pattern scan failed: {e}'}

    def _calculate_memory_threat_level(self, malware_patterns: Dict) -> str:
        """Calculate threat level based on malware patterns"""
        try:
            threat_score = 0
            
            # Count patterns found
            for category, patterns in malware_patterns.items():
                if isinstance(patterns, list):
                    threat_score += len(patterns) * 10
                elif isinstance(patterns, dict) and 'error' in patterns:
                    threat_score += 5
            
            # Determine threat level
            if threat_score >= 80:
                return 'critical'
            elif threat_score >= 60:
                return 'high'
            elif threat_score >= 40:
                return 'medium'
            else:
                return 'low'
                
        except Exception:
            return 'low'

    def get_memory_protection_statistics(self) -> Dict:
        """Get memory protection statistics"""
        return {
            'protection_active': self.protection_active,
            'memory_regions_monitored': self.protection_stats['memory_regions_monitored'],
            'injection_attempts_blocked': self.protection_stats['injection_attempts_blocked'],
            'memory_violations_detected': self.protection_stats['memory_violations_detected'],
            'shellcode_detected': self.protection_stats['shellcode_detected'],
            'dll_injections_blocked': self.protection_stats['dll_injections_blocked'],
            'code_injections_blocked': self.protection_stats['code_injections_blocked'],
            'protection_errors': self.protection_stats['protection_errors'],
            'memory_regions_size': len(self.memory_regions),
            'memory_violations_size': len(self.memory_violations),
            'injection_attempts_size': len(self.injection_attempts)
        }

    def get_recent_violations(self, count: int = 10) -> List[Dict]:
        """Get recent memory violations"""
        return list(self.memory_violations)[-count:]

    def get_recent_injections(self, count: int = 10) -> List[Dict]:
        """Get recent injection attempts"""
        return list(self.injection_attempts)[-count:]

    def update_protection_config(self, config: Dict):
        """Update memory protection configuration"""
        try:
            self.protection_config.update(config)
            print(f"‚úÖ Memory protection configuration updated")
        except Exception as e:
            print(f"‚ùå Configuration update error: {e}")

    def add_custom_pattern(self, pattern_type: str, pattern: bytes):
        """Add custom memory pattern for detection"""
        try:
            if pattern_type not in self.memory_patterns:
                self.memory_patterns[pattern_type] = []
            
            self.memory_patterns[pattern_type].append(pattern)
            print(f"‚úÖ Custom pattern added: {pattern_type}")
        except Exception as e:
            print(f"‚ùå Pattern addition error: {e}")

    def emergency_memory_lockdown(self):
        """Emergency memory lockdown mode"""
        try:
            print("üö® EMERGENCY MEMORY LOCKDOWN ACTIVATED!")
            
            # Increase protection level
            self.protection_config['protection_level'] = 'maximum'
            self.protection_config['max_memory_usage'] = 50  # Reduce to 50%
            
            # Block all suspicious processes
            for proc in psutil.process_iter(['pid', 'name', 'memory_info']):
                try:
                    if proc.info['memory_info'].percent > 30:
                        print(f"üö® BLOCKING HIGH MEMORY PROCESS: {proc.info['name']} (PID: {proc.info['pid']})")
                        # In real implementation, you'd terminate or suspend the process
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    continue
            
            print("‚úÖ Emergency memory lockdown completed!")
            
        except Exception as e:
            print(f"‚ùå Emergency lockdown error: {e}")

    def restore_normal_protection(self):
        """Restore normal memory protection"""
        try:
            print("‚úÖ Restoring normal memory protection...")
            
            # Restore normal protection level
            self.protection_config['protection_level'] = 'high'
            self.protection_config['max_memory_usage'] = 80  # Restore to 80%
            
            print("‚úÖ Normal memory protection restored!")
            
        except Exception as e:
            print(f"‚ùå Protection restoration error: {e}")
