import time
import threading
import psutil
import os
import subprocess
from collections import deque
from typing import Dict, List, Optional, Tuple
import json
import hashlib
import socket
import platform

class ProcessMonitor:
    def __init__(self):
        self.monitoring_active = False
        self.monitoring_thread = None
        self.process_history = deque(maxlen=10000)
        self.suspicious_processes = deque(maxlen=1000)
        self.process_terminations = deque(maxlen=500)
        
        # Process monitoring configuration
        self.monitor_config = {
            'monitor_cpu_usage': True,
            'monitor_memory_usage': True,
            'monitor_network_connections': True,
            'monitor_file_operations': True,
            'monitor_registry_operations': True,
            'monitor_process_creation': True,
            'monitor_process_termination': True,
            'monitor_dll_loading': True,
            'monitor_service_creation': True,
            'monitor_scheduled_tasks': True,
            'max_cpu_usage': 80,  # 80%
            'max_memory_usage': 80,  # 80%
            'monitoring_interval': 2  # seconds
        }
        
        # Suspicious process patterns
        self.suspicious_patterns = {
            'process_names': [
                'malware', 'virus', 'trojan', 'backdoor', 'keylogger', 'spyware',
                'ransomware', 'botnet', 'rootkit', 'worm', 'adware'
            ],
            'command_line_patterns': [
                'powershell -enc', 'cmd /c', 'wscript', 'cscript', 'rundll32',
                'regsvr32', 'schtasks', 'at', 'net user', 'net localgroup',
                'wmic', 'vssadmin', 'bcdedit', 'reg add', 'reg delete'
            ],
            'network_patterns': [
                'high_frequency_connections', 'suspicious_ports', 'tor_usage',
                'proxy_usage', 'encrypted_traffic', 'unusual_domains'
            ],
            'file_patterns': [
                'mass_file_creation', 'system_file_modification', 'encryption_activity',
                'deletion_spree', 'hidden_files', 'executable_in_data'
            ],
            'registry_patterns': [
                'startup_modification', 'service_creation', 'policy_changes',
                'security_settings', 'user_account_creation'
            ]
        }
        
        # Process monitoring statistics
        self.monitor_stats = {
            'processes_monitored': 0,
            'suspicious_processes_detected': 0,
            'processes_terminated': 0,
            'dll_injections_detected': 0,
            'service_creations_detected': 0,
            'scheduled_tasks_detected': 0,
            'monitoring_errors': 0
        }
        
        # Known safe processes
        self.safe_processes = {
            'system', 'idle', 'csrss', 'winlogon', 'services', 'lsass',
            'svchost', 'explorer', 'dwm', 'wininit', 'smss', 'conhost'
        }
        
        print("üîç Process Monitor initialized!")
        print(f"   Monitoring interval: {self.monitor_config['monitoring_interval']}s")
        print(f"   Max CPU usage: {self.monitor_config['max_cpu_usage']}%")
        print(f"   Max memory usage: {self.monitor_config['max_memory_usage']}%")
        print(f"   Suspicious patterns: {sum(len(v) for v in self.suspicious_patterns.values())}")

    def start_monitoring(self):
        """Start process monitoring"""
        if self.monitoring_active:
            return
        self.monitoring_active = True
        self.monitoring_thread = threading.Thread(target=self._monitoring_loop, daemon=True)
        self.monitoring_thread.start()
        print("üîç Process monitoring started!")

    def stop_monitoring(self):
        """Stop process monitoring"""
        self.monitoring_active = False
        if self.monitoring_thread:
            self.monitoring_thread.join(timeout=5)
        print("‚èπÔ∏è Process monitoring stopped!")

    def _monitoring_loop(self):
        """Main process monitoring loop"""
        while self.monitoring_active:
            try:
                self._monitor_running_processes()
                self._monitor_process_creation()
                self._monitor_process_termination()
                self._monitor_dll_loading()
                self._monitor_service_creation()
                self._monitor_scheduled_tasks()
                time.sleep(self.monitor_config['monitoring_interval'])
            except Exception as e:
                print(f"‚ùå Process monitoring error: {e}")
                self.monitor_stats['monitoring_errors'] += 1
                time.sleep(self.monitor_config['monitoring_interval'])

    def _monitor_running_processes(self):
        """Monitor currently running processes"""
        try:
            current_time = time.time()
            
            for proc in psutil.process_iter(['pid', 'name', 'cpu_percent', 'memory_percent', 'create_time', 'cmdline', 'connections']):
                try:
                    proc_info = proc.info
                    if proc_info['pid'] == 0:  # Skip system processes
                        continue
                    
                    # Create process data
                    process_data = {
                        'timestamp': current_time,
                        'pid': proc_info['pid'],
                        'name': proc_info['name'],
                        'cpu_percent': proc_info['cpu_percent'],
                        'memory_percent': proc_info['memory_percent'],
                        'create_time': proc_info['create_time'],
                        'cmdline': proc_info['cmdline'],
                        'connections': len(proc_info['connections']) if proc_info['connections'] else 0
                    }
                    
                    self.process_history.append(process_data)
                    self.monitor_stats['processes_monitored'] += 1
                    
                    # Check for suspicious behavior
                    self._check_process_anomalies(process_data)
                    
                except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
                    continue
                    
        except Exception as e:
            print(f"‚ùå Running processes monitoring error: {e}")

    def _monitor_process_creation(self):
        """Monitor for new process creation"""
        try:
            # Get current process list
            current_processes = set()
            for proc in psutil.process_iter(['pid']):
                try:
                    current_processes.add(proc.info['pid'])
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    continue
            
            # Check for new processes (simplified implementation)
            # In a real scenario, you'd use process creation hooks
            for proc in psutil.process_iter(['pid', 'name', 'create_time', 'cmdline']):
                try:
                    proc_info = proc.info
                    if proc_info['pid'] == 0:
                        continue
                    
                    # Check if process was created recently
                    if time.time() - proc_info['create_time'] < 10:  # Created in last 10 seconds
                        self._analyze_new_process(proc_info)
                        
                except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
                    continue
                    
        except Exception as e:
            print(f"‚ùå Process creation monitoring error: {e}")

    def _monitor_process_termination(self):
        """Monitor for process termination"""
        try:
            # This is a simplified implementation
            # In a real scenario, you'd use process termination hooks
            
            # Monitor for processes that were running but are no longer running
            current_pids = set()
            for proc in psutil.process_iter(['pid']):
                try:
                    current_pids.add(proc.info['pid'])
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    continue
            
            # Check for terminated processes
            for process_data in self.process_history:
                if process_data['pid'] not in current_pids:
                    termination = {
                        'timestamp': time.time(),
                        'pid': process_data['pid'],
                        'name': process_data['name'],
                        'termination_time': time.time() - process_data['timestamp']
                    }
                    
                    self.process_terminations.append(termination)
                    self.monitor_stats['processes_terminated'] += 1
                    
                    print(f"üìù Process terminated: {process_data['name']} (PID: {process_data['pid']})")
                    
        except Exception as e:
            print(f"‚ùå Process termination monitoring error: {e}")

    def _monitor_dll_loading(self):
        """Monitor for DLL loading"""
        try:
            # This is a simplified implementation
            # In a real scenario, you'd use DLL loading hooks
            
            for proc in psutil.process_iter(['pid', 'name', 'memory_info']):
                try:
                    proc_info = proc.info
                    if proc_info['pid'] == 0:
                        continue
                    
                    # Check for suspicious DLL loading patterns
                    dll_loading = self._detect_dll_loading(proc_info)
                    
                    if dll_loading:
                        self.monitor_stats['dll_injections_detected'] += 1
                        
                        print(f"üö® DLL LOADING DETECTED: {proc_info['name']} (PID: {proc_info['pid']})")
                        print(f"   DLL: {dll_loading['dll_name']}")
                        print(f"   Method: {dll_loading['method']}")
                        print(f"   Confidence: {dll_loading['confidence']:.1f}%")
                        
                except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
                    continue
                    
        except Exception as e:
            print(f"‚ùå DLL loading monitoring error: {e}")

    def _monitor_service_creation(self):
        """Monitor for service creation"""
        try:
            # This is a simplified implementation
            # In a real scenario, you'd use service creation hooks
            
            # Check for new services (simplified)
            for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
                try:
                    proc_info = proc.info
                    if proc_info['pid'] == 0:
                        continue
                    
                    # Check for service creation commands
                    if proc_info['cmdline']:
                        cmdline = ' '.join(proc_info['cmdline']).lower()
                        service_commands = ['sc create', 'net start', 'services.msc']
                        
                        for cmd in service_commands:
                            if cmd in cmdline:
                                self.monitor_stats['service_creations_detected'] += 1
                                
                                print(f"üö® SERVICE CREATION DETECTED: {proc_info['name']} (PID: {proc_info['pid']})")
                                print(f"   Command: {cmdline}")
                                
                except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
                    continue
                    
        except Exception as e:
            print(f"‚ùå Service creation monitoring error: {e}")

    def _monitor_scheduled_tasks(self):
        """Monitor for scheduled task creation"""
        try:
            # This is a simplified implementation
            # In a real scenario, you'd use scheduled task hooks
            
            # Check for scheduled task creation commands
            for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
                try:
                    proc_info = proc.info
                    if proc_info['pid'] == 0:
                        continue
                    
                    # Check for scheduled task commands
                    if proc_info['cmdline']:
                        cmdline = ' '.join(proc_info['cmdline']).lower()
                        task_commands = ['schtasks', 'at', 'task scheduler']
                        
                        for cmd in task_commands:
                            if cmd in cmdline:
                                self.monitor_stats['scheduled_tasks_detected'] += 1
                                
                                print(f"üö® SCHEDULED TASK CREATION DETECTED: {proc_info['name']} (PID: {proc_info['pid']})")
                                print(f"   Command: {cmdline}")
                                
                except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
                    continue
                    
        except Exception as e:
            print(f"‚ùå Scheduled task monitoring error: {e}")

    def _check_process_anomalies(self, process_data: Dict):
        """Check for process anomalies"""
        try:
            anomalies = []
            
            # Check CPU usage
            if process_data['cpu_percent'] > self.monitor_config['max_cpu_usage']:
                anomalies.append('high_cpu_usage')
            
            # Check memory usage
            if process_data['memory_percent'] > self.monitor_config['max_memory_usage']:
                anomalies.append('high_memory_usage')
            
            # Check for suspicious process names
            process_name = process_data['name'].lower()
            for suspicious_name in self.suspicious_patterns['process_names']:
                if suspicious_name in process_name:
                    anomalies.append('suspicious_process_name')
                    break
            
            # Check for suspicious command line patterns
            if process_data['cmdline']:
                cmdline = ' '.join(process_data['cmdline']).lower()
                for pattern in self.suspicious_patterns['command_line_patterns']:
                    if pattern in cmdline:
                        anomalies.append('suspicious_command_line')
                        break
            
            # Check for high network activity
            if process_data['connections'] > 20:
                anomalies.append('high_network_activity')
            
            # Report anomalies
            if anomalies:
                self._report_process_anomaly(process_data, anomalies)
                
        except Exception as e:
            print(f"‚ùå Process anomaly check error: {e}")

    def _analyze_new_process(self, proc_info: Dict):
        """Analyze newly created process"""
        try:
            # Check if process is suspicious
            suspicious_indicators = []
            
            # Check process name
            process_name = proc_info['name'].lower()
            for suspicious_name in self.suspicious_patterns['process_names']:
                if suspicious_name in process_name:
                    suspicious_indicators.append('suspicious_process_name')
                    break
            
            # Check command line
            if proc_info['cmdline']:
                cmdline = ' '.join(proc_info['cmdline']).lower()
                for pattern in self.suspicious_patterns['command_line_patterns']:
                    if pattern in cmdline:
                        suspicious_indicators.append('suspicious_command_line')
                        break
            
            # Report suspicious new process
            if suspicious_indicators:
                self._report_suspicious_process(proc_info, suspicious_indicators)
                
        except Exception as e:
            print(f"‚ùå New process analysis error: {e}")

    def _detect_dll_loading(self, proc_info: Dict) -> Optional[Dict]:
        """Detect DLL loading in process"""
        try:
            # This is a simplified implementation
            # Real implementation would use DLL loading hooks
            
            # Check for suspicious DLL loading patterns
            if proc_info['name'].lower() in ['malware', 'virus', 'trojan']:
                return {
                    'dll_name': 'suspicious.dll',
                    'method': 'detected_loading',
                    'confidence': 80.0
                }
            
            # Check for high memory usage (potential DLL injection)
            if proc_info['memory_info'].percent > 50:
                return {
                    'dll_name': 'unknown.dll',
                    'method': 'high_memory_usage',
                    'confidence': 60.0
                }
            
            return None
            
        except Exception as e:
            print(f"‚ùå DLL loading detection error: {e}")
            return None

    def _report_process_anomaly(self, process_data: Dict, anomalies: List[str]):
        """Report process anomaly"""
        try:
            anomaly_report = {
                'timestamp': time.time(),
                'type': 'process_anomaly',
                'pid': process_data['pid'],
                'name': process_data['name'],
                'anomalies': anomalies,
                'cpu_percent': process_data['cpu_percent'],
                'memory_percent': process_data['memory_percent'],
                'connections': process_data['connections']
            }
            
            self.suspicious_processes.append(anomaly_report)
            self.monitor_stats['suspicious_processes_detected'] += 1
            
            print(f"üö® PROCESS ANOMALY DETECTED: {process_data['name']} (PID: {process_data['pid']})")
            print(f"   Anomalies: {', '.join(anomalies)}")
            print(f"   CPU: {process_data['cpu_percent']:.1f}%, Memory: {process_data['memory_percent']:.1f}%")
            print(f"   Connections: {process_data['connections']}")
            
        except Exception as e:
            print(f"‚ùå Process anomaly reporting error: {e}")

    def _report_suspicious_process(self, proc_info: Dict, indicators: List[str]):
        """Report suspicious process"""
        try:
            suspicious_report = {
                'timestamp': time.time(),
                'type': 'suspicious_process',
                'pid': proc_info['pid'],
                'name': proc_info['name'],
                'indicators': indicators,
                'cmdline': proc_info['cmdline']
            }
            
            self.suspicious_processes.append(suspicious_report)
            self.monitor_stats['suspicious_processes_detected'] += 1
            
            print(f"üö® SUSPICIOUS PROCESS DETECTED: {proc_info['name']} (PID: {proc_info['pid']})")
            print(f"   Indicators: {', '.join(indicators)}")
            if proc_info['cmdline']:
                print(f"   Command: {' '.join(proc_info['cmdline'])}")
            
        except Exception as e:
            print(f"‚ùå Suspicious process reporting error: {e}")

    def terminate_process(self, pid: int, force: bool = False) -> bool:
        """Terminate a process"""
        try:
            proc = psutil.Process(pid)
            
            if force:
                proc.kill()
                print(f"üî™ Process forcefully terminated: {proc.name()} (PID: {pid})")
            else:
                proc.terminate()
                print(f"üî™ Process terminated: {proc.name()} (PID: {pid})")
            
            return True
            
        except psutil.NoSuchProcess:
            print(f"‚ùå Process not found: {pid}")
            return False
        except psutil.AccessDenied:
            print(f"‚ùå Access denied for process: {pid}")
            return False
        except Exception as e:
            print(f"‚ùå Process termination error: {e}")
            return False

    def suspend_process(self, pid: int) -> bool:
        """Suspend a process"""
        try:
            proc = psutil.Process(pid)
            proc.suspend()
            print(f"‚è∏Ô∏è Process suspended: {proc.name()} (PID: {pid})")
            return True
            
        except psutil.NoSuchProcess:
            print(f"‚ùå Process not found: {pid}")
            return False
        except psutil.AccessDenied:
            print(f"‚ùå Access denied for process: {pid}")
            return False
        except Exception as e:
            print(f"‚ùå Process suspension error: {e}")
            return False

    def resume_process(self, pid: int) -> bool:
        """Resume a suspended process"""
        try:
            proc = psutil.Process(pid)
            proc.resume()
            print(f"‚ñ∂Ô∏è Process resumed: {proc.name()} (PID: {pid})")
            return True
            
        except psutil.NoSuchProcess:
            print(f"‚ùå Process not found: {pid}")
            return False
        except psutil.AccessDenied:
            print(f"‚ùå Access denied for process: {pid}")
            return False
        except Exception as e:
            print(f"‚ùå Process resumption error: {e}")
            return False

    def analyze_process(self, pid: int) -> Dict:
        """Analyze a specific process"""
        try:
            proc = psutil.Process(pid)
            
            # Get process information
            proc_info = {
                'pid': pid,
                'name': proc.name(),
                'cpu_percent': proc.cpu_percent(),
                'memory_percent': proc.memory_percent(),
                'memory_info': proc.memory_info(),
                'create_time': proc.create_time(),
                'cmdline': proc.cmdline(),
                'connections': len(proc.connections()),
                'threads': proc.num_threads(),
                'open_files': len(proc.open_files()),
                'status': proc.status()
            }
            
            # Analyze process behavior
            behavior_analysis = self._analyze_process_behavior(proc_info)
            
            # Calculate threat level
            threat_level = self._calculate_process_threat_level(proc_info, behavior_analysis)
            
            return {
                'process_info': proc_info,
                'behavior_analysis': behavior_analysis,
                'threat_level': threat_level,
                'analysis_timestamp': time.time()
            }
            
        except Exception as e:
            return {'error': f'Process analysis failed: {e}'}

    def _analyze_process_behavior(self, proc_info: Dict) -> Dict:
        """Analyze process behavior"""
        try:
            behavior_analysis = {
                'suspicious_indicators': [],
                'resource_usage': {},
                'network_activity': {},
                'file_activity': {},
                'behavior_score': 0
            }
            
            # Check for suspicious indicators
            if proc_info['cpu_percent'] > 80:
                behavior_analysis['suspicious_indicators'].append('high_cpu_usage')
                behavior_analysis['behavior_score'] += 20
            
            if proc_info['memory_percent'] > 50:
                behavior_analysis['suspicious_indicators'].append('high_memory_usage')
                behavior_analysis['behavior_score'] += 20
            
            if proc_info['connections'] > 20:
                behavior_analysis['suspicious_indicators'].append('high_network_activity')
                behavior_analysis['behavior_score'] += 15
            
            if proc_info['threads'] > 50:
                behavior_analysis['suspicious_indicators'].append('high_thread_count')
                behavior_analysis['behavior_score'] += 10
            
            if proc_info['open_files'] > 100:
                behavior_analysis['suspicious_indicators'].append('high_file_activity')
                behavior_analysis['behavior_score'] += 10
            
            # Check for suspicious process names
            process_name = proc_info['name'].lower()
            for suspicious_name in self.suspicious_patterns['process_names']:
                if suspicious_name in process_name:
                    behavior_analysis['suspicious_indicators'].append('suspicious_process_name')
                    behavior_analysis['behavior_score'] += 30
                    break
            
            # Check for suspicious command line
            if proc_info['cmdline']:
                cmdline = ' '.join(proc_info['cmdline']).lower()
                for pattern in self.suspicious_patterns['command_line_patterns']:
                    if pattern in cmdline:
                        behavior_analysis['suspicious_indicators'].append('suspicious_command_line')
                        behavior_analysis['behavior_score'] += 25
                        break
            
            # Resource usage analysis
            behavior_analysis['resource_usage'] = {
                'cpu_percent': proc_info['cpu_percent'],
                'memory_percent': proc_info['memory_percent'],
                'memory_rss': proc_info['memory_info'].rss,
                'memory_vms': proc_info['memory_info'].vms,
                'threads': proc_info['threads']
            }
            
            # Network activity analysis
            behavior_analysis['network_activity'] = {
                'connections': proc_info['connections'],
                'high_activity': proc_info['connections'] > 20
            }
            
            # File activity analysis
            behavior_analysis['file_activity'] = {
                'open_files': proc_info['open_files'],
                'high_activity': proc_info['open_files'] > 100
            }
            
            return behavior_analysis
            
        except Exception as e:
            return {'error': f'Behavior analysis failed: {e}'}

    def _calculate_process_threat_level(self, proc_info: Dict, behavior_analysis: Dict) -> str:
        """Calculate process threat level"""
        try:
            behavior_score = behavior_analysis.get('behavior_score', 0)
            
            # Determine threat level based on behavior score
            if behavior_score >= 80:
                return 'critical'
            elif behavior_score >= 60:
                return 'high'
            elif behavior_score >= 40:
                return 'medium'
            else:
                return 'low'
                
        except Exception:
            return 'low'

    def get_monitoring_statistics(self) -> Dict:
        """Get process monitoring statistics"""
        return {
            'monitoring_active': self.monitoring_active,
            'processes_monitored': self.monitor_stats['processes_monitored'],
            'suspicious_processes_detected': self.monitor_stats['suspicious_processes_detected'],
            'processes_terminated': self.monitor_stats['processes_terminated'],
            'dll_injections_detected': self.monitor_stats['dll_injections_detected'],
            'service_creations_detected': self.monitor_stats['service_creations_detected'],
            'scheduled_tasks_detected': self.monitor_stats['scheduled_tasks_detected'],
            'monitoring_errors': self.monitor_stats['monitoring_errors'],
            'process_history_size': len(self.process_history),
            'suspicious_processes_size': len(self.suspicious_processes),
            'process_terminations_size': len(self.process_terminations)
        }

    def get_recent_suspicious_processes(self, count: int = 10) -> List[Dict]:
        """Get recent suspicious processes"""
        return list(self.suspicious_processes)[-count:]

    def get_recent_process_terminations(self, count: int = 10) -> List[Dict]:
        """Get recent process terminations"""
        return list(self.process_terminations)[-count:]

    def update_monitoring_config(self, config: Dict):
        """Update process monitoring configuration"""
        try:
            self.monitor_config.update(config)
            print(f"‚úÖ Process monitoring configuration updated")
        except Exception as e:
            print(f"‚ùå Configuration update error: {e}")

    def add_custom_pattern(self, pattern_type: str, pattern: str):
        """Add custom pattern for detection"""
        try:
            if pattern_type not in self.suspicious_patterns:
                self.suspicious_patterns[pattern_type] = []
            
            self.suspicious_patterns[pattern_type].append(pattern)
            print(f"‚úÖ Custom pattern added: {pattern_type}")
        except Exception as e:
            print(f"‚ùå Pattern addition error: {e}")

    def emergency_process_lockdown(self):
        """Emergency process lockdown mode"""
        try:
            print("üö® EMERGENCY PROCESS LOCKDOWN ACTIVATED!")
            
            # Terminate all suspicious processes
            for proc in psutil.process_iter(['pid', 'name', 'cpu_percent', 'memory_percent']):
                try:
                    proc_info = proc.info
                    if proc_info['pid'] == 0:
                        continue
                    
                    # Check if process is suspicious
                    if (proc_info['cpu_percent'] > 80 or 
                        proc_info['memory_percent'] > 50 or
                        any(name in proc_info['name'].lower() for name in self.suspicious_patterns['process_names'])):
                        
                        print(f"üö® TERMINATING SUSPICIOUS PROCESS: {proc_info['name']} (PID: {proc_info['pid']})")
                        self.terminate_process(proc_info['pid'], force=True)
                        
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    continue
            
            print("‚úÖ Emergency process lockdown completed!")
            
        except Exception as e:
            print(f"‚ùå Emergency lockdown error: {e}")

    def restore_normal_monitoring(self):
        """Restore normal process monitoring"""
        try:
            print("‚úÖ Restoring normal process monitoring...")
            
            # Resume normal monitoring
            self.monitor_config['max_cpu_usage'] = 80
            self.monitor_config['max_memory_usage'] = 80
            
            print("‚úÖ Normal process monitoring restored!")
            
        except Exception as e:
            print(f"‚ùå Monitoring restoration error: {e}")
